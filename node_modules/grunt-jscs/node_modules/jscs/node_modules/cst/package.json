{
  "name": "cst",
  "version": "0.4.6",
  "description": "JavaScript CST Implementation",
  "author": {
    "name": "Marat Dulin"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/cst/cst"
  },
  "bugs": {
    "url": "https://github.com/cst/cst/issues"
  },
  "maintainers": [
    {
      "name": "Henry Zhu",
      "email": "hi@henryzoo.com"
    },
    {
      "name": "Oleg Gaidarenko",
      "email": "markelog@gmail.com"
    }
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "scripts": {
    "test": "npm run lint && npm run test:unit",
    "test:unit": "mocha",
    "test:live": "mocha --watch",
    "test:benchmark": "babel-node test/benchmarks/benchmarks.js",
    "watch": "gaze 'npm run build' 'src/**/*.js'",
    "lint": "npm run lint:jscs",
    "lint:jscs": "jscs src test",
    "flow": "flow check",
    "build": "babel src -d lib --source-maps",
    "precommit": "npm test",
    "release": "npm run build && npm publish",
    "postpublish": "rm -Rf lib"
  },
  "devDependencies": {
    "babel-cli": "^6.6.5",
    "babel-plugin-transform-class-properties": "^6.6.0",
    "babel-plugin-transform-flow-strip-types": "^6.7.0",
    "babel-plugin-transform-object-rest-spread": "^6.6.5",
    "babel-plugin-transform-runtime": "^6.9.0",
    "babel-preset-es2015": "^6.6.0",
    "babel-register": "^6.9.0",
    "benchmark": "^2.1.0",
    "chai": "^3.5.0",
    "chalk": "^1.1.1",
    "gaze-cli": "^0.2.0",
    "husky": "^0.11.4",
    "jscs": "^2.11.0",
    "mocha": "^2.5.3"
  },
  "dependencies": {
    "babel-runtime": "^6.9.2",
    "babylon": "^6.8.1",
    "source-map-support": "^0.4.0"
  },
  "files": [
    "lib"
  ],
  "readme": "[![Build Status](https://travis-ci.org/cst/cst.svg?branch=master)](https://travis-ci.org/cst/cst)\n\n# JavaScript CST implementation\n\n## CST\n\nCheck out code [samples](https://github.com/cst/cst/wiki/How-to-add-a-property-to-an-object) and rest of the wiki for more.\n\n`CST` means Concrete Syntax Tree. Unlike an `AST` (Abstract Syntax Tree), a `CST` contains all the information\nfrom the JavaScript source file: whitespace, punctuators, comments. This information is extremely useful for\ncode style checkers and other code linters. `CST` is also useful for cases when you need to apply modifications\nto existing JavaScript files while preserving the initial file formatting.\n\nThis `CST` implementation is designed to be `100%` compatible with JS `AST` (https://github.com/estree/estree).\n\nMain principles:\n\n* CST contains all the information from a parsed file (including whitespace and comments).\n* Compatible with AST (https://github.com/estree/estree).\n* Requires tokens to modify CST structure.\n* The tree is always valid (it protects itself against breaking changes).\n* CST can be rendered to valid JS at any time.\n\nLet's see an example:\n\n```js\nx = 0;\nif (x) x++;\n```\n\nThe CST for this example:\n\n![](https://raw.githubusercontent.com/cst/cst/master/docs/cst-example.png)\n\n* Blue text — CST Tokens.\n* White text in blue blocks — CST Nodes (their structure is equal to an AST).\n* Blue lines — CST Structure.\n* Red lined — AST Links.\n\n## Classes\n\n### Element\n\n`Element` is the base class for `Node` and `Token`.\n\n```js\ndeclare class Element {\n\n  // traversal for children\n  childElements: Array<Element>;\n  firstChild: ?Element;\n  lastChild: ?Element;\n\n  // traversal for parent\n  parentElement: ?Element;\n\n  // traversing between siblings\n  nextSibling: ?Element;\n  previousSibling: ?Element;\n\n  // traversing to first/last tokens (not only direct tokens)\n  getFirstToken(): ?Token;\n  getLastToken(): ?Token;\n\n  // traversing to next/previous tokens (not only siblings)\n  getNextToken(): ?Token;\n  getPreviousToken(): ?Token;\n\n  // Code properties\n  type: string;\n  isToken: boolean;\n  isNode: boolean;\n  isExpression: boolean;\n  isStatement: boolean;\n  isWhitespace: boolean;\n  isFragment: boolean;\n  isFragment: boolean;\n  isModuleDeclaration: boolean;\n  isModuleSpecifier: boolean;\n\n  // Code methods\n  getSourceCode(): string;\n  getSourceCodeLength(): number;\n\n  // Mutation methods\n\n  // appends child to the end of the `Element`\n  appendChild(newElement: Element): void;\n  // prepends child to the end of the `Element`\n  prependChild(newElement: Element): void;\n  // inserts child before `referenceChild`\n  insertChildBefore(newElement: Element, referenceChild: Element): void;\n  // replaces specified child interval (from `firstChildRef` to lastChildRef`) with specified child.\n  replaceChildren(newElement: Element, firstRefChild: Element, lastRefChild: Element): void;\n\n  // Location methods\n  getRange(): Range;\n  getLoc(): Location;\n}\n\ndeclare class Token extends Element {\n  // token value\n  value: string;\n}\n\ntype Range = [\n    start: number;\n    end: number;\n];\n\ntype Position = {\n  line: number,\n  column: number\n};\n\ntype Location = {\n  start: Position,\n  end: Position\n};\n```\n\n### Node\n\n`Node` extends `Element`. The Nodes are the \"AST part of a CST\". If you drop everything but Nodes from a `CST`, you will\nget a pure `AST` from the Node structure. So it is fair to say that Nodes provide the `AST` logic for a `CST`. Currently\nonly Nodes can contain children.\n\nThe Node property `isNode` always returns `true`.\n\n### Token\n\n`Token` extends `Element`. The purpose of a `CST` is to have tokens in the tree. By only manipulating tokens,\nwe can change code formatting without any effect on the behaviour.\n\nThe Token property `isToken` always returns `true`.\n",
  "readmeFilename": "README.md",
  "_id": "cst@0.4.6",
  "_from": "cst@^0.4.3"
}
